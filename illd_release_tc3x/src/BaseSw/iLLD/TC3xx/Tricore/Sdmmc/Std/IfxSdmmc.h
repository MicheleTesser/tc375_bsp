/**
 * \file IfxSdmmc.h
 * \brief SDMMC  basic functionality
 * \ingroup IfxLld_Sdmmc
 *
 * \version iLLD_1_21_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Sdmmc_Std_Enumerations Enumerations
 * \ingroup IfxLld_Sdmmc_Std
 * \defgroup IfxLld_Sdmmc_Std_DataStrctures Data Strctures
 * \ingroup IfxLld_Sdmmc_Std
 * \defgroup IfxLld_Sdmmc_Std_Functions Functions
 * \ingroup IfxLld_Sdmmc_Std
 */

#ifndef IFXSDMMC_H
#define IFXSDMMC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxSdmmc_cfg.h"
#include "IfxSdmmc_reg.h"
#include "IfxScu_reg.h"
#include "Src/Std/IfxSrc.h"
#include "Scu/Std/IfxScuWdt.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief CMD0, Response: none\n
 * Resets all cards to idle state.
 */
#define IFXSDMMC_CMD0_GO_IDLE_STATE                (0x00)

/** \brief CMD2, Response: R2\n
 * Asks any card to send the CID numbers on the CMD line (any card that is connected to the host will respond)
 */
#define IFXSDMMC_CMD2_ALL_SEND_CID                 (0x02)

/** \brief CMD3, Response: R6\n
 * Ask the card to publish a new relative address (RCA)
 */
#define IFXSDMMC_CMD3_SEND_RELATIVE_ADDR           (0x03)

/** \brief CMD4, Response: none\n
 * Programs the DSR of all cards
 */
#define IFXSDMMC_CMD4_SET_DSR                      (0x04)

/** \brief MMC CMD6
 */
#define IFXSDMMC_CMD6_SWITCH_FUNC                  (0x06)

/** \brief CMD7, Response: R1b (only from the slected card)\n
 * Command toggles a card between the stand-by and transfer states or\n
 * between the programming and disconnect states. In both cases, the card is selected by \n
 * its own relative address and gets deselected by any other address; address 0 deselects all\n
 * In the case that the RCA equals 0, then the host may do one of the following:\n
 * - Use other RCA number to perform card de-selection.\n
 * - Re-send CMD3 to change its RCA number to other than 0 and then use CMD7 with RCA=0 for card deselection.\n
 */
#define IFXSDMMC_CMD7_SELECT_DESELECT_CARD         (0x07)

/** \brief CMD8, Response: R8\n
 * Sends SD Memory Card interface condition, which includes host supply voltage information\n
 * and asks the card whether card supports voltage. Reserved bits shall be set to '0'.
 */
#define IFXSDMMC_CMD8_SEND_IF_COND                 (0x08)

/** \brief CMD9, Response: R2\n
 * Addressed card sends its card-specific data (CSD) on the CMD line.
 */
#define IFXSDMMC_CMD9_SEND_CSD                     (0x09)

/** \brief CMD10, Response: R2\n
 * Addressed card sends its card identification (CID) on CMD the line.
 */
#define IFXSDMMC_CMD10_SEND_CID                    (0x0A)

/** \brief CMD11, Response: R1\n
 * Switch to 1.8V bus signaling level.
 */
#define IFXSDMMC_CMD11_VOLTAGE_SWITCH              (0x0B)

/** \brief CMD12, Response: R1b\n
 * Forces the card to stop transmission
 */
#define IFXSDMMC_CMD12_STOP_TRANSMISSION           (0x0C)

/** \brief CMD13, Response: R1\n
 * Addressed card sends its status register.
 */
#define IFXSDMMC_CMD13_SEND_STATUS                 (0x0D)

/** \brief CMD15, Response: none\n
 * Sends an addressed card into the Inactive State. This command is used \n
 * when the host explicitly wants to deactivate a card. Reserved bits shall be set to '0'.
 */
#define IFXSDMMC_CMD15_GO_INACTIVE_STATE           (0x0F)

/** \brief CMD16, Response: R1\n
 * In the case of a Standard Capacity SD Memory Card, this command sets the block length (in bytes)\n
 * for all following block commands (read, write, lock). Default block length is fixed to 512 Bytes. \n
 * Set length is valid for memory access commands only if partial block read operation are allowed in CSD.\n
 * In the case of SDHC and SDXC Cards, block length set by CMD16 command does not affect \n
 * memory read and write commands. Always 512 Bytes fixed block length is used. \n
 * This command is effective for LOCK_UNLOCK command. In both cases, if block length is set larger than 512Bytes, \n
 * the card sets the BLOCK_LEN_ERROR bit. In DDR50 mode, data is sampled on both edges of the clock.\n
 * Therefore, block length shall always be even.\n
 */
#define IFXSDMMC_CMD16_SET_BLOCKLEN                (0x10)

/** \brief CMD17, Response: R1\n
 * In the case of a Standard Capacity SD Memory Card, this command, this command reads a block \n
 * of the size selected by the SET_BLOCKLEN command. \n
 * In case of SDHC and SDXC Cards, block length is fixed 512 Bytes regardless of the SET_BLOCKLEN command.
 */
#define IFXSDMMC_CMD17_READ_SINGLE_BLOCK           (0x11)

/** \brief CMD18, Response: R1\n
 * Continuously transfers data blocks from card to host until interrupted by a STOP_TRANSMISSION command.\n
 * Block length is specified the same as READ_SINGLE_BLOCK command.
 */
#define IFXSDMMC_CMD18_READ_MULTIPLE_BLOCK         (0x12)

/** \brief CMD19, Response: R1\n
 * 64 bytes tuning pattern is sent for SDR50 and SDR104.
 */
#define IFXSDMMC_CMD19_SEND_TUNING_BLOCK           (0x13)

/** \brief CMD20, Response: R1b\n
 * Speed Class control command.
 */
#define IFXSDMMC_CMD20_SPEED_CLASS_CONTROL         (0x14)

/** \brief CMD23, Response: R1\n
 * Specify block count for CMD18 and CMD25.
 */
#define IFXSDMMC_CMD23_SET_BLOCK_COUNT             (0x17)

/** \brief CMD24, Response: R1\n
 * In case of SDSC Card, block length is set by the SET_BLOCKLEN command\n
 * In case of SDHC and SDXC Cards, block length is fixed 512 Bytes regardless of the SET_BLOCKLEN command.
 */
#define IFXSDMMC_CMD24_WRITE_BLOCK                 (0x18)

/** \brief CMD25, Response: R1\n
 * Continuously writes blocks of data until a STOP_TRANSMISSION follows.\n
 * Block length is specified the same as WRITE_BLOCK command.
 */
#define IFXSDMMC_CMD25_WRITE_MULTIPLE_BLOCK        (0x19)

/** \brief CMD27, Response: R1\n
 * Programming of the programmable bits of the CSD.
 */
#define IFXSDMMC_CMD27_PROGRAM_CSD                 (0x1B)

/** \brief CMD28, Response: R1b\n
 * If the card has write protection features, this command sets the write protection bit of the addressed group.\n
 * The properties of write protection are coded in the card specific data (WP_GRP_SIZE)\n
 * SDHC and SDXC Cards do not support this command.
 */
#define IFXSDMMC_CMD28_SET_WRITE_PROT              (0x1C)

/** \brief CMD29, Response: R1b\n
 * If the card provides write protection features, this command clears the write protection bit of the addressed group.\n
 * SDHC and SDXC Cards do not support this command.
 */
#define IFXSDMMC_CMD29_CLR_WRITE_PROT              (0x1D)

/** \brief CMD30, Response: R1\n
 * If the card provides write protection features, this command asks the card to send the status of the write protection bits.1\n
 * SDHC and SDXC Cards do not support this command.
 */
#define IFXSDMMC_CMD30_SEND_WRITE_PROT             (0x1E)

/** \brief CMD32, Response: R1\n
 * Sets the address of the first write block to be erased.
 */
#define IFXSDMMC_CMD32_ERASE_WR_BLK_START          (0x20)

/** \brief CMD33, Response: R1\n
 * Sets the address of the last write block of the continuous range to be erased.
 */
#define IFXSDMMC_CMD33_ERASE_WR_BLK_END            (0x21)

/** \brief CMD38, Response: R1b\n
 * Erases all previously selected write blocks.
 */
#define IFXSDMMC_CMD38_ERASE                       (0x26)

/** \brief CMD42, Response: R1\n
 * Used to set/reset the password or lock/unlock the card. The size of the data block is set by the SET_BLOCK_LEN command.\n
 * Reserved bits in the argument and in Lock Card Data Structure shall be set to 0.
 */
#define IFXSDMMC_CMD42_LOCK_UNLOCK                 (0x2A)

/** \brief CMD55, Response: R1\n
 * Indicates to the card that the next command is an application specific command rather than a standard command
 */
#define IFXSDMMC_CMD55_APP_CMD                     (0x37)

/** \brief CMD56, Response: R1\n
 * Used either to transfer a data block to the card or to get a data block from the card for general purpose/application specific commands. \n
 * In case of a SDSC Card, block length is set by the SET_BLOCK_LEN command. \n
 * In case of SDHC and SDXC Cards, block length is fixed to 512 bytes.\n
 * The host sets RD/WR=1 for reading data from thecard and sets to 0 for writing data to the card.\n
 */
#define IFXSDMMC_CMD56_GEN_CMD                     (0x38)

/** \brief ACMD6, should be followed by CMD55, Response: R1\n
 * Defines the data bus width ('00'=1bit or '10'=4 bits bus) to be used for data transfer. \n
 * The allowed data bus widths are given in SCR register.
 */
#define IFXSDMMC_ACMD6_SET_BUS_WIDTH               (0x06)

/** \brief ACMD13, should be followed by CMD55, Response: R1\n
 * Send the SD Status.
 */
#define IFXSDMMC_ACMD13_SD_STATUS                  (0x0D)

/** \brief ACMD22, should be followed by CMD55, Response: R1\n
 * Send the number of the written (without errors) write blocks. Responds with 32bit+CRC data block.\n
 * If WRITE_BL_PARTIAL='0', the unit of ACMD22 is always 512 byte.\n
 * If WRITE_BL_PARTIAL='1', the unit of ACMD22 is a block length which was used when the write command was executed.
 */
#define IFXSDMMC_ACMD22_SEND_NUM_WR_BLOCKS         (0x16)

/** \brief ACMD23, should be followed by CMD55, Response: R1\n
 * Set the number of write blocks to be pre-erased before writing (to be used for faster Multiple Block WR command). \n
 * "1"=default (one wr block)
 */
#define IFXSDMMC_ACMD23_SET_WR_BLK_ERASE_COUNT     (0x17)

/** \brief ACMD41, should be followed by CMD55, Response: R1\n
 * Sends host capacity support information (HCS) and asks the accessed card to send its operating condition register (OCR) content \n
 * in the response on the CMD line. HCS is effective when card receives SEND_IF_COND command.\n
 * Sends request to switch to 1.8V signaling (S18R). Reserved bit shall be set to '0'. CCS bit is assigned to OCR[30].\n
 * XPC controls the maximum power in the default speed mode of SDXC card. XPC=0 means 0.36W (100mA at 3.6V on VDD1) (max.) \n
 * but speed class is not supported. XPC=1 means 0.54W (150mA at 3.6V on VDD1) (max.) and speed class is supported.
 */
#define IFXSDMMC_ACMD41_SD_SEND_OP_COND            (0x29)

/** \brief ACMD42, should be followed by CMD55, Response: R1\n
 * Connect[1]/Disconnect[0] the 50 KOhm pull-up resistor on CD/DAT3 (pin 1) of the card.
 */
#define IFXSDMMC_ACMD42_SET_CLR_CARD_DETECT        (0x1A)

/** \brief ACMD51, should be followed by CMD55, Response: R1\n
 * Reads the SD Configuration Register (SCR).
 */
#define IFXSDMMC_ACMD51_SEND_SCR                   (0x33)

/** \brief MMC CMD1,
 */
#define IFXSDMMC_CMD1_MMC_SEND_OP_COND             (0x01)

/** \brief MMC CMD3,
 */
#define IFXSDMMC_CMD3_MMC_SET_RELATIVE_ADDR        (0x03)

/** \brief MMC CMD5,
 */
#define IFXSDMMC_CMD5_MMC_SLEEP_AWAKE              (0x05)

/** \brief MMC CMD6
 */
#define IFXSDMMC_CMD6_MMC_SWITCH_FUNC              (0x06)

/** \brief MMC CMD8
 */
#define IFXSDMMC_CMD8_MMC_SEND_EXT_CSD             (0x08)

/** \brief MMC CMD35
 */
#define IFXSDMMC_CMD35_MMC_ERASE_GROUP_START       (0x23)

/** \brief MMC CMD36
 */
#define IFXSDMMC_CMD36_MMC_ERASE_GROUP_END         (0x24)

/** \brief Argument none (Stuff bits)
 */
#define IFXSDMMC_ARG_NONE                          (0x00000000U)

/** \brief Argument for Command 8
 */
#define IFXSDMMC_ARG_CMD8                          (0x000001AAU)

/** \brief Arguments for ACMD41 F80 (HCS=0)
 */
#define IFXSDMMC_ARG_ACMD41_F80                    (0x00100000U)

/** \brief Argument for switching SD card to 4 bit mode
 */
#define IFXSDMMC_ARG_SD_BUSWIDTH_4                 (0x00000002U)

/** \brief Arguments for ACMD41 F81 (HCS=1)
 */
#define IFXSDMMC_ARG_ACMD41_F81                    (0x40100000U)

/** \brief Argument for switching SD card to high speed mode
 */
#define IFXSDMMC_ARG_SD_HIGHSPEED                  (0x80000001U)

/** \brief Argument for switching MMC card to 4 bit mode
 */
#define IFXSDMMC_ARG_MMC_BUSWIDTH_4                (0x03B70100U)

/** \brief Argument for switching MMC card to high speed mode
 */
#define IFXSDMMC_ARG_MMC_HIGHSPEED                 (0x03B90100U)

/** \brief Defalut transfer block size
 */
#define IFXSDMMC_BLOCK_SIZE_DEFAULT                ((uint16)512)

/** \brief Argument for MMC CMD1
 */
#define IFXSDMMC_ARG_MMCCMD1                       (0x40FF8080U)

/** \brief Card relative address RCA none
 */
#define IFXSDMMC_RCA_NONE                          (0x00000000U)

/** \brief Voltage check: Host supported voltage 2.7 to 3.6V
 */
#define IFXSDMMC_HOST_SUPPORTED_VOLTAGE            (0x1)

/** \brief Interface Condition Command (CMD8) Check Pattern
 */
#define IFXSDMMC_IF_COND_CHECK_PATTERN             (0xAA)

/** \brief Mask for Card power up status bit (busy)
 */
#define IFXSDMMC_CARD_POWERUP_STATUS_MASK          (0x80000000)

/** \brief CMD register reserved bitfild value
 */
#define IFXSDMMC_CMD_REG_BIT_RES                   (0)

/** \brief Argument for switching MMC card to 8 bit mode
 */
#define IFXSDMMC_ARG_MMC_BUSWIDTH_8                (0x03B70200U)

/** \brief Argument for TRIM option in ERASE command.
 */
#define IFXSDMMC_ARG_CMD38_TRIM                    (0x00000001u)

/** \brief CMD5, Response: R5
 * Request Card operation condition
 */
#define IFXSDMMC_CMD5_IO_SEND_OP_COND              (0x05)

/** \brief SDIO CMD52
 * Read/Write Register Direct
 */
#define IFXSDMMC_CMD52_IO_RW_DIRECT                (0x34)

/** \brief SDIO CMD53
 * Read / Write Register Blocks
 */
#define IFXSDMMC_CMD53_IO_RW_EXTENDED              (0x35)

/** \brief SD Memory Card R1 status error check Mask
 */
#define IFXSDMMC_CARD_R1STATUS_ERROR_CHECK_MSK     (0xFD398008)

/** \brief SDIO card R1 status error check mask.
 */
#define IFXSDMMC_IOCARD_R1STATUS_ERROR_CHECK_MSK   (0x80C80000)

/** \brief SD memory card R6 status error check mask
 */
#define IFXSDMMC_CARD_R6STATUS_ERROR_CHECK_MSK     (0xE008)

/** \brief SDIO card R6 status error check mask
 */
#define IFXSDMMC_IOCARD_R6STATUS_ERROR_CHECK_MSK   (0xE000)

/** \brief SDIO card (IO only) error status check mask
 */
#define IFXSDMMC_CARD_IOONLY_STATUS_CHECK_MSK      (0x00001D00)

/** \brief Argument for CMD5 for SDIO : 3.2-3.3V OCR WV
 */
#define IFXSDMMC_ARG_CMD5_WV                       ((uint32)(0x00100000U))

/** \brief error check mask for CMD52, CMD53 for SDIO
 * value: 0b1100 1011
 */
#define IFXSDMMC_IOCARD_R5RESPONSE_ERROR_CHECK_MSK ((uint8)0xCB)

/** \brief CCCR: address of IO enable register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_IOEX            ((uint32)0x02)

/** \brief CCCR: address of Card capability register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_CARDCPBLTY      ((uint32)0x08)

/** \brief CCCR: Card Capability: LSC bit position
 */
#define IFXSDMMC_SDIO_CCCR_CARDCPBLTY_LSC_BITPOS   ((uint8)6)

/** \brief CCCR: Card Capability: 4BLS bit position
 */
#define IFXSDMMC_SDIO_CCCR_CARDCPBLTY_4BLS_BITPOS  ((uint8)7)

/** \brief CCCR: Card Capability: SMB bit position
 */
#define IFXSDMMC_SDIO_CCCR_CARDCPBLTY_SMB_BITPOS   ((uint8)1)

/** \brief CCCR: Card Capability: S4MI bit position
 */
#define IFXSDMMC_SDIO_CCCR_CARDCPBLTY_S4MI_BITPOS  ((uint8)4)

/** \brief CCCR: Card Capability: E4MI bit position
 */
#define IFXSDMMC_SDIO_CCCR_CARDCPBLTY_E4MI_BITPOS  ((uint8)5)

/** \brief CCCR: address of BUS IF CONTROL register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_BUSIFCTRL       ((uint32)0x7)

/** \brief CCCR: Address of Interrupt Enable Register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_INTENABLE       ((uint32)0x04)

/** \brief CCCR: Address of Interrupt Pending Register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_INTPENDING      ((uint32)0x05)

/** \brief CCCR: address of bus speed select register
 */
#define IFXSDMMC_SDIO_CCCR_ADDRESS_BUSSPEEDSEL     ((uint32)0x13)

/** \brief CCCR: Bus speed select: SHS bit position
 */
#define IFXSDMMC_SDIO_CCCR_BUSSPEEDSEL_SHS_BITPOS  ((uint32)0x00)

/** \brief Macro to calculate the BlockSize Register Address of function
 */
#define IFXSDMMC_SDIO_FBR_ADDRESS_BLOCKSIZE(func) ((((uint32)0x100) * func) + (uint32)0x10)

/** \brief CCCR: Bus speed select: EHS bit position
 */
#define IFXSDMMC_SDIO_CCCR_BUSSPEEDSEL_EHS_BITPOS  ((uint32)0x01)

/** \brief Initialization Frequency of SD card - SD spec max: 400KHz
 */
#ifndef IFXSDMMC_INIT_FREQUENCY
#define IFXSDMMC_INIT_FREQUENCY                    ((uint32)(400000))
#endif

/** \brief Physical Time duration (microseconds) for achieving 74 cycle clock delay
 */
#define IFXSDMMC_DELAY_74CYCLE_US                  ((uint32)((74 * 1000000) / IFXSDMMC_INIT_FREQUENCY))

/** \brief Number of CPU cycles for one loop of delay
 */
#define IFXSDMMC_1LOOP_CPUCYCLES                   ((uint32)(3))

/** \brief Time delay (microseconds) for 1000 loop counts
 */
#define IFXSDMMC_1KLOOPDELAY_US                    ((uint32)((IFXSDMMC_1LOOP_CPUCYCLES * (uint32)1000 * (uint32)1000000) / IfxScuCcu_getCpuFrequency(IfxCpu_getCoreIndex())))

/** \brief Delay between two tries of CMD5 for SDIO card
 */
#define IFXSDMMC_SDIO_RETRYDELAY_CMD5_US           ((uint32)(3 * 1000))

/** \brief Number of retries of CMD5 (every 3ms for 1second)
 */
#define IFXSDMMC_SDIO_RETRYCOUNT_CMD5_1S           ((uint32)(350))

/** \brief Delay between retries for ACMD41
 */
#ifndef IFXSDMMC_RETRYDELAY_ACMD41_US
#define IFXSDMMC_RETRYDELAY_ACMD41_US              ((uint32)(3 * 1000))
#endif

/** \brief Number or retries of ACMD41 for memory cards (every 3ms for 1s)
 */
#define IFXSDMMC_RETRYCOUNT_ACMD41_1S              ((uint32)(350))

/** \brief Multiplier for the calculation
 */
#define IFXSDMMC_1KMULTIPLIER (1000)  

/** \brief Block size 512
 */
#define IFXSDMMC_BLOCKSIZE_512 (512)

/** \brief Block size 64
 */
#define IFXSDMMC_BLOCKSIZE_64 (64)

/** \brief Block size 8
 */
#define IFXSDMMC_BLOCKSIZE_8 (8)

/** \brief Bit shit 31
 */
#define IFXSDMMC_BITSHIFT_POS31 (31)

/** \brief Bit shit 16
 */
#define IFXSDMMC_BITSHIFT_POS16 (16)

/** \brief Bit shit 8
 */
#define IFXSDMMC_BITSHIFT_POS8 (8)

/** \brief Bit shit 2
 */
#define IFXSDMMC_BITSHIFT_POS2 (2)

/** \brief 10MHz Frequency parameter
 */
#define IFXSDMMC_FREQUENCY_10MHZ (10000000)

/** \brief 50MHz Frequency parameter
 */
#define IFXSDMMC_FREQUENCY_50MHZ (50000000)

/** \brief 26MHz Frequency parameter
 */
#define IFXSDMMC_FREQUENCY_26MHZ (26000000)

/** \brief timeout value 1e6
 */ 
#define IFXSDMMC_TIMEOUT_1E6 (1000000)

/** \brief timeout value 1e5 
 */ 
#define IFXSDMMC_TIMEOUT_1E5 (100000)

/** \brief RCA CMD3
 */
#define IFXSDMMC_RCACMD3 (0x2)

/** \brief SD/eMMC Bus Voltage Select for VDD1 (3.3V)
 */
#define IFXSDMMC_BUS_VOLTAGE_SELECT_VDD (7)

/** \brief High Capacity Card Check
 */
#define IFXSDMMC_STATUS_HIGHCAPACITYCARD (0x40000000)

/** \brief Max clock frequency multiplier
 */ 
#define IFXSDMMC_MAXCLOCKFREQ (1000000)

/** \brief Card Capacity Byte addressing pattern
 */
#define IFXSDMMC_CARDCAPACITY_BYTEADDRESSING_PATTERN (0x80FF8080)

/** \brief Card Capacity Sector addressing pattern
 */
#define IFXSDMMC_CARDCAPACITY_SECTORADDRESSING_PATTERN (0xC0FF8080)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Sdmmc_Std_Enumerations
 * \{ */
/** \brief Length mode of ADMA2 descriptor
 * Definition in Ifx_SDMMC.HOST_CTRL2.B.ADMA2_LEN_MODE
 */
typedef enum
{
    IfxSdmmc_Adma2LengthMode_16Bit,  /**< \brief 16 Bit length in ADMA2 descriptor */
    IfxSdmmc_Adma2LengthMode_26Bit   /**< \brief 26 Bit Desriptor length */
} IfxSdmmc_Adma2LengthMode;

/** \brief Combination of Act2, Act1 and Act0 of ADMA descriptors
 */
typedef enum
{
    IfxSdmmc_AdmaActionSymbol_nop  = 0,  /**< \brief No Operation, do not execute current line and go to next line */
    IfxSdmmc_AdmaActionSymbol_rsv  = 2,  /**< \brief Reserved, same as nop */
    IfxSdmmc_AdmaActionSymbol_tran = 4,  /**< \brief Transfer Data, transfer data of one descriptor line */
    IfxSdmmc_AdmaActionSymbol_link = 6   /**< \brief Link Descriptor, Link to another descriptor */
} IfxSdmmc_AdmaActionSymbol;

/** \brief Auto CMD select mode for multiBlock Transfers
 * Definition in Ifx_SDMMC.XFER_MODE.B.AUTO_CMD_ENABLE
 */
typedef enum
{
    IfxSdmmc_AutoCmdSelect_disable,  /**< \brief disable Auto CMD feature */
    IfxSdmmc_AutoCmdSelect_cmd12,    /**< \brief Auto send cmd12 command */
    IfxSdmmc_AutoCmdSelect_cmd23,    /**< \brief Auto send cmd23 command */
    IfxSdmmc_AutoCmdSelect_auto      /**< \brief auto decide command */
} IfxSdmmc_AutoCmdSelect;

/** \brief block boundary size\n
 * Definition in Ifx_SDMMC.XFER_MODE.B.MULTI_BLK_SEL
 */
typedef enum
{
    IfxSdmmc_BlockBoundarySize_4K,    /**< \brief SDMA Buffer Boundary 4K size */
    IfxSdmmc_BlockBoundarySize_8K,    /**< \brief SDMA Buffer Boundary 8K size */
    IfxSdmmc_BlockBoundarySize_16K,   /**< \brief SDMA Buffer Boundary 16K size */
    IfxSdmmc_BlockBoundarySize_32K,   /**< \brief SDMA Buffer Boundary 32K size */
    IfxSdmmc_BlockBoundarySize_64K,   /**< \brief SDMA Buffer Boundary 64K size */
    IfxSdmmc_BlockBoundarySize_128K,  /**< \brief SDMA Buffer Boundary 128K size */
    IfxSdmmc_BlockBoundarySize_256K,  /**< \brief SDMA Buffer Boundary 256K size */
    IfxSdmmc_BlockBoundarySize_512K   /**< \brief SDMA Buffer Boundary 512K size */
} IfxSdmmc_BlockBoundarySize;

/** \brief Card lock status
 */
typedef enum
{
    IfxSdmmc_CardLockStatus_unlocked,  /**< \brief Card in Unlocked state */
    IfxSdmmc_CardLockStatus_locked     /**< \brief Locked */
} IfxSdmmc_CardLockStatus;

/** \brief The state of the card
 */
typedef enum
{
    IfxSdmmc_CardState_initialised    = 0,  /**< \brief initialised */
    IfxSdmmc_CardState_notInitialised = 1,  /**< \brief Not Initialised */
    IfxSdmmc_CardState_noCard         = 2,  /**< \brief No Card */
    IfxSdmmc_CardState_writeProtected = 4,  /**< \brief Write Protected */
    IfxSdmmc_CardState_locked         = 8,  /**< \brief Locked */
    IfxSdmmc_CardState_commandActive  = 16, /**< \brief Command Active */
    IfxSdmmc_CardState_dataActive     = 32, /**< \brief Data Active */
    IfxSdmmc_CardState_hcInitialised  = 64  /**< \brief HC Initialised */
} IfxSdmmc_CardState;

/** \brief Card Type
 */
typedef enum
{
    IfxSdmmc_CardType_sd,   /**< \brief SD card */
    IfxSdmmc_CardType_emmc  /**< \brief eMMC card */
} IfxSdmmc_CardType;

/** \brief Command
 */
typedef enum
{
    IfxSdmmc_Command_goIdleState,            /**< \brief Go Idle State, CMD0 */
    IfxSdmmc_Command_allSendCID,             /**< \brief All Send CID, CMD2 */
    IfxSdmmc_Command_sendRelativeAddress,    /**< \brief Send Relative Address, CMD3 */
    IfxSdmmc_Command_setDSR,                 /**< \brief Set DSR, CMD4 */
    IfxSdmmc_Command_switchFunction,         /**< \brief Switch Function, CMD6 */
    IfxSdmmc_Command_selectDeselectCard,     /**< \brief Select Deselect Card, CMD7 */
    IfxSdmmc_Command_sendIfCond,             /**< \brief Send If Cond, CMD8 */
    IfxSdmmc_Command_sendCSD,                /**< \brief Send CSD, CMD9 */
    IfxSdmmc_Command_sendCID,                /**< \brief Send CID, CMD10 */
    IfxSdmmc_Command_stopTransmission,       /**< \brief Stop Transmission, CMD12 */
    IfxSdmmc_Command_sendStatus,             /**< \brief Send Status, CMD13 */
    IfxSdmmc_Command_goInactiveState,        /**< \brief Go Inactive State, CMD15 */
    IfxSdmmc_Command_setBlockLength,         /**< \brief Set Block Length, CMD16 */
    IfxSdmmc_Command_readSingleBlock,        /**< \brief Read Single Block, CMD17 */
    IfxSdmmc_Command_readMultipleBLock,      /**< \brief Read Multiple Block, CMD18 */
    IfxSdmmc_Command_writeBlock,             /**< \brief Write Block, CMD24 */
    IfxSdmmc_Command_writeMultipleBlock,     /**< \brief Write Multiple Block, CMD25 */
    IfxSdmmc_Command_programCSD,             /**< \brief Program CSD, CMD27 */
    IfxSdmmc_Command_setWriteProtect,        /**< \brief Set Write Protect, CMD28 */
    IfxSdmmc_Command_clearWriteProtect,      /**< \brief Clear Write Protect, CMD29 */
    IfxSdmmc_Command_sendWriteProtect,       /**< \brief Send Write Protect, CMD30 */
    IfxSdmmc_Command_eraseWrBlkStart,        /**< \brief Erase Wr Blk Start, CMD32 */
    IfxSdmmc_Command_eraseWrBlkEnd,          /**< \brief Erase Wr Blk End, CMD33 */
    IfxSdmmc_Command_erase,                  /**< \brief Erase, CMD38 */
    IfxSdmmc_Command_lockUnlock,             /**< \brief Lock Unlock, CMD42 */
    IfxSdmmc_Command_appCommand,             /**< \brief App Command, CMD55 */
    IfxSdmmc_Command_genCommand,             /**< \brief Gen Command, CMD56 */
    IfxSdmmc_Command_setBusWidth,            /**< \brief Set Bus Width, ACMD6 */
    IfxSdmmc_Command_sdStatus,               /**< \brief SD Status, ACMD13 */
    IfxSdmmc_Command_sendNumWrBlocks,        /**< \brief Send Num Wr Blocks, CMDACMD22 */
    IfxSdmmc_Command_setWrBlkEraseCount,     /**< \brief Set Wr Blk Erase Count, ACMD23 */
    IfxSdmmc_Command_sdSendOpCond,           /**< \brief Sd Send Op Cond, ACMD41 */
    IfxSdmmc_Command_setClrCardDetect,       /**< \brief Set Clr Card Detect, ACMD42 */
    IfxSdmmc_Command_sendSCR,                /**< \brief Send SCR */
    IfxSdmmc_Command_mmcSendOpCond,          /**< \brief MMC Send Op Cond, MMC_CMD1 */
    IfxSdmmc_Command_mmcSetRelativeAddress,  /**< \brief MMC Set Relative Address, MMC_CMD3 */
    IfxSdmmc_Command_mmcSleepAwake,          /**< \brief MMC Sleep Awake, MMC_CMD5 */
    IfxSdmmc_Command_mmcSwitchFunction,      /**< \brief MMC Switch Funtion, MMC_CMD6 */
    IfxSdmmc_Command_mmcSendExtCSD,          /**< \brief MMC Send Ext CSD, MMC_CMD8 */
    IfxSdmmc_Command_mmcEraseGroupStart,     /**< \brief MMC Erase Group Start, MMC_CMD35 */
    IfxSdmmc_Command_mmcEraseGroupEnd,       /**< \brief MMC Erase Group End, MMC_CMD36 */
    IfxSdmmc_Command_ioSendOpCond,           /**< \brief IO request for operating condition CMD5 */
    IfxSdmmc_Command_ioRwDirect,             /**< \brief IO RW direct, CMD52 */
    IfxSdmmc_Command_ioRwExtended            /**< \brief IO RW extended, CMD53 */
} IfxSdmmc_Command;

/** \brief Command type\n
 * Definition in CMD.CMD_CRC_CHK_ENABLE
 */
typedef enum
{
    IfxSdmmc_CommandCrcCheck_disable,  /**< \brief Disable */
    IfxSdmmc_CommandCrcCheck_enable    /**< \brief Enable */
} IfxSdmmc_CommandCrcCheck;

/** \brief Command type\n
 * Definition in CMD.SUB_CMD_FLAG
 */
typedef enum
{
    IfxSdmmc_CommandFlag_main,  /**< \brief Main Command */
    IfxSdmmc_CommandFlag_sub    /**< \brief Sub Command */
} IfxSdmmc_CommandFlag;

/** \brief Command type\n
 * Definition in CMD.CMD_IDX_CHK_ENABLE
 */
typedef enum
{
    IfxSdmmc_CommandIndexCheck_disable,  /**< \brief Disable */
    IfxSdmmc_CommandIndexCheck_enable    /**< \brief Enable */
} IfxSdmmc_CommandIndexCheck;

/** \brief Command type\n
 * Definition in CMD.CMD_TYPE
 */
typedef enum
{
    IfxSdmmc_CommandType_normal,   /**< \brief Normal Command */
    IfxSdmmc_CommandType_suspend,  /**< \brief Suspend Command */
    IfxSdmmc_CommandType_resume,   /**< \brief Resume Command */
    IfxSdmmc_CommandType_abort     /**< \brief Abort Command */
} IfxSdmmc_CommandType;

/** \brief the interval by which DAT line timeouts are detected\n
 * Definition in TOUT_CTRL.TOUT_CNT
 */
typedef enum
{
    IfxSdmmc_DataLineTimeout_2Power13,     /**< \brief TMCLK * 2Power13  */
    IfxSdmmc_DataLineTimeout_2Power14,     /**< \brief TMCLK * 2Power14  */
    IfxSdmmc_DataLineTimeout_2Power15,     /**< \brief TMCLK * 2Power15  */
    IfxSdmmc_DataLineTimeout_2Power16,     /**< \brief TMCLK * 2Power16  */
    IfxSdmmc_DataLineTimeout_2Power17,     /**< \brief TMCLK * 2Power17  */
    IfxSdmmc_DataLineTimeout_2Power18,     /**< \brief TMCLK * 2Power18  */
    IfxSdmmc_DataLineTimeout_2Power19,     /**< \brief TMCLK * 2Power19  */
    IfxSdmmc_DataLineTimeout_2Power20,     /**< \brief TMCLK * 2Power20  */
    IfxSdmmc_DataLineTimeout_2Power21,     /**< \brief TMCLK * 2Power21  */
    IfxSdmmc_DataLineTimeout_2Power22,     /**< \brief TMCLK * 2Power22  */
    IfxSdmmc_DataLineTimeout_2Power23,     /**< \brief TMCLK * 2Power23  */
    IfxSdmmc_DataLineTimeout_2Power24,     /**< \brief TMCLK * 2Power24  */
    IfxSdmmc_DataLineTimeout_2Power25,     /**< \brief TMCLK * 2Power25  */
    IfxSdmmc_DataLineTimeout_2Power26,     /**< \brief TMCLK * 2Power26  */
    IfxSdmmc_DataLineTimeout_2Power27      /**< \brief TMCLK * 2Power27  */
} IfxSdmmc_DataLineTimeout;

/** \brief Command type\n
 * Definition in CMD.DATA_PRESENT_SEL
 */
typedef enum
{
    IfxSdmmc_DataPresentSelect_noData,   /**< \brief No Data Present */
    IfxSdmmc_DataPresentSelect_withData  /**< \brief Data Present */
} IfxSdmmc_DataPresentSelect;

/** \brief Dma Type,\n
 * Definition in HOST_CTRL1.DMA_SEL
 */
typedef enum
{
    IfxSdmmc_DmaType_sdma     = 0, /**< \brief SDMA */
    IfxSdmmc_DmaType_adma2    = 2, /**< \brief ADMA2 */
    IfxSdmmc_DmaType_adma2Or3 = 3  /**< \brief ADMA2 or ADMA3 */
} IfxSdmmc_DmaType;

/** \brief EMMC card capacity
 */
typedef enum
{
    IfxSdmmc_EmmcCardCapacity_byteAddressing   = 0, /**< \brief less than 2GB: Byte Addressing */
    IfxSdmmc_EmmcCardCapacity_sectorAddressing = 1  /**< \brief More than 2GB : Sector Addressing */
} IfxSdmmc_EmmcCardCapacity;

/** \brief Data width of the host controller, number of data lines.\n
 * Definition in HOST_CTRL1.DAT_XFER_WIDTH and HOST_CTRL1.EXT_DAT_XFER
 */
typedef enum
{
    IfxSdmmc_EmmcDataTransferWidth_1Bit,  /**< \brief 1 bit mode */
    IfxSdmmc_EmmcDataTransferWidth_4Bit,  /**< \brief 4 bit mode */
    IfxSdmmc_EmmcDataTransferWidth_8Bit   /**< \brief 8 bit mode */
} IfxSdmmc_EmmcDataTransferWidth;

/** \brief Speed Mode\n
 * Definition HOST_CTRL2.UHS_MODE
 */
typedef enum
{
    IfxSdmmc_EmmcSpeedMode_legacy,       /**< \brief eMMC Speed mode: Legacy */
    IfxSdmmc_EmmcSpeedMode_highSpeedSdr  /**< \brief eMMC Speed mode: High Speed SDR */
} IfxSdmmc_EmmcSpeedMode;

/** \brief Error Interrupts\n
 * Definition in ERROR_INT_STAT, ERROR_INT_STAT_EN, ERROR_INT_SIGNAL_EN
 */
typedef enum
{
    IfxSdmmc_ErrorInterrupt_commandTimeout,      /**< \brief Command Timeout Error */
    IfxSdmmc_ErrorInterrupt_commandCrc,          /**< \brief Command Crc Error */
    IfxSdmmc_ErrorInterrupt_commandEndBit,       /**< \brief Command End Bit Error */
    IfxSdmmc_ErrorInterrupt_commandIndex,        /**< \brief Command Index Error */
    IfxSdmmc_ErrorInterrupt_dataTimeout,         /**< \brief Data Timeout Error */
    IfxSdmmc_ErrorInterrupt_dataCrc,             /**< \brief Data Crc Error */
    IfxSdmmc_ErrorInterrupt_dataEndBit,          /**< \brief Data End Bit Error */
    IfxSdmmc_ErrorInterrupt_currentLimit,        /**< \brief Current Limit Error */
    IfxSdmmc_ErrorInterrupt_autoCommand,         /**< \brief Auto CMD Error (SD/eMMC Mode only) */
    IfxSdmmc_ErrorInterrupt_adma,                /**< \brief ADMA Error */
    IfxSdmmc_ErrorInterrupt_tuning,              /**< \brief Tuning Error */
    IfxSdmmc_ErrorInterrupt_response,            /**< \brief Response Error */
    IfxSdmmc_ErrorInterrupt_bootAcknowledgement  /**< \brief Boot Acknowledgement Error */
} IfxSdmmc_ErrorInterrupt;

/** \brief Function IO enable status
 */
typedef enum
{
    IfxSdmmc_FunctionIO_disabled,  /**< \brief IO disabled */
    IfxSdmmc_FunctionIO_enabled,   /**< \brief IO enabled */
    IfxSdmmc_FunctionIO_unknown    /**< \brief IO status unkown */
} IfxSdmmc_FunctionIO;

/** \brief Interrupt Type
 */
typedef enum
{
    IfxSdmmc_InterruptType_normal,  /**< \brief Normal Interrupt type */
    IfxSdmmc_InterruptType_dma      /**< \brief Error Interrupt type */
} IfxSdmmc_InterruptType;

/** \brief Normal Interrupts\n
 * Definition in NORMAL_INT_STAT, NORMAL_INT_STAT_EN, NORMAL_INT_SIGNAL_EN
 */
typedef enum
{
    IfxSdmmc_NormalInterrupt_commandComplete,      /**< \brief Command Complete */
    IfxSdmmc_NormalInterrupt_transferComplete,     /**< \brief Transfer Complete */
    IfxSdmmc_NormalInterrupt_blockGapEvent,        /**< \brief Block Gap Event */
    IfxSdmmc_NormalInterrupt_dma,                  /**< \brief DMA */
    IfxSdmmc_NormalInterrupt_bufferWriteReady,     /**< \brief Buffer Write Ready */
    IfxSdmmc_NormalInterrupt_bufferReadReady,      /**< \brief Buffer Read Ready */
    IfxSdmmc_NormalInterrupt_cardInsertion,        /**< \brief Card Insertion */
    IfxSdmmc_NormalInterrupt_cardRemoval,          /**< \brief Card Removal */
    IfxSdmmc_NormalInterrupt_card,                 /**< \brief Card Interrupt */
    IfxSdmmc_NormalInterrupt_a,                    /**< \brief INT_A */
    IfxSdmmc_NormalInterrupt_b,                    /**< \brief INT_B */
    IfxSdmmc_NormalInterrupt_c,                    /**< \brief INT_C */
    IfxSdmmc_NormalInterrupt_reTuningEvent,        /**< \brief Re Tuning Event */
    IfxSdmmc_NormalInterrupt_fXEvent,              /**< \brief FX Event */
    IfxSdmmc_NormalInterrupt_commandQueuingEvent,  /**< \brief Command Queuing Event */
    IfxSdmmc_NormalInterrupt_error                 /**< \brief Error */
} IfxSdmmc_NormalInterrupt;

/** \brief Response Length\n
 * Definition in CMD.RESP_TYPE_SELECT
 */
typedef enum
{
    IfxSdmmc_ResponseLength_none,            /**< \brief No Response */
    IfxSdmmc_ResponseLength_136,             /**< \brief Response Length 136 */
    IfxSdmmc_ResponseLength_48,              /**< \brief Response Length 48 */
    IfxSdmmc_ResponseLength_48WithBusyCheck  /**< \brief Response Length 48 (check Busy after response) */
} IfxSdmmc_ResponseLength;

/** \brief Response Type
 */
typedef enum
{
    IfxSdmmc_ResponseType_none,  /**< \brief No Response */
    IfxSdmmc_ResponseType_r1,    /**< \brief R1 */
    IfxSdmmc_ResponseType_r1b,   /**< \brief R1b */
    IfxSdmmc_ResponseType_r2,    /**< \brief R2 */
    IfxSdmmc_ResponseType_r3,    /**< \brief R3 */
    IfxSdmmc_ResponseType_r4,    /**< \brief R4 */
    IfxSdmmc_ResponseType_r5,    /**< \brief R5 */
    IfxSdmmc_ResponseType_r6,    /**< \brief R6 */
    IfxSdmmc_ResponseType_r7     /**< \brief R7 */
} IfxSdmmc_ResponseType;

/** \brief Card Capacity
 */
typedef enum
{
    IfxSdmmc_SdCardCapacity_standardV2      = 1, /**< \brief Capcity V2 */
    IfxSdmmc_SdCardCapacity_standardV1x     = 2, /**< \brief Capacity V1x */
    IfxSdmmc_SdCardCapacity_high            = 4, /**< \brief High Capacity */
    IfxSdmmc_SdCardCapacity_blockAddressing = 8  /**< \brief Block Addressing */
} IfxSdmmc_SdCardCapacity;

/** \brief enum holding card type
 */
typedef enum
{
    IfxSdmmc_SdCardType_io = 1,  /**< \brief IO only card */
    IfxSdmmc_SdCardType_mem,     /**< \brief Memory only card */
    IfxSdmmc_SdCardType_combo    /**< \brief Combo card */
} IfxSdmmc_SdCardType;

/** \brief Data width of the host controller, number of data lines.\n
 * Definition in HOST_CTRL1.DAT_XFER_WIDTH
 */
typedef enum
{
    IfxSdmmc_SdDataTransferWidth_1Bit,  /**< \brief 1 bit mode */
    IfxSdmmc_SdDataTransferWidth_4Bit   /**< \brief 4 bit mode */
} IfxSdmmc_SdDataTransferWidth;

/** \brief Enum holding the function numbers
 */
typedef enum
{
    IfxSdmmc_SdIoFunction_none = -1, /**< \brief Not Selected */
    IfxSdmmc_SdIoFunction_0,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_1,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_2,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_3,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_4,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_5,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_6,         /**< \brief "Function"+str(x)  */
    IfxSdmmc_SdIoFunction_7          /**< \brief "Function"+str(x)  */
} IfxSdmmc_SdIoFunction;

/** \brief Init Status of SDIO card
 */
typedef enum
{
    IfxSdmmc_SdIoInit_notReady,  /**< \brief Not Initialized */
    IfxSdmmc_SdIoInit_ready      /**< \brief Initialized */
} IfxSdmmc_SdIoInit;

/** \brief SDIO Function Interrupt Pending Status
 */
typedef enum
{
    IfxSdmmc_SdIoInterruptPendingStatus_cleared,  /**< \brief Interrupt cleared */
    IfxSdmmc_SdIoInterruptPendingStatus_pending,  /**< \brief Interrupt pending */
    IfxSdmmc_SdIoInterruptPendingStatus_unknown   /**< \brief Interrupt Pending Status unknown */
} IfxSdmmc_SdIoInterruptPendingStatus;

/** \brief SDIO Function Interrupt Status
 */
typedef enum
{
    IfxSdmmc_SdIoInterruptStatus_disabled,  /**< \brief Interrupt disabled */
    IfxSdmmc_SdIoInterruptStatus_enabled,   /**< \brief Interrupt enabled */
    IfxSdmmc_SdIoInterruptStatus_unknown    /**< \brief Interrupt status unkown */
} IfxSdmmc_SdIoInterruptStatus;

/** \brief SDIO bus width for transfer
 */
typedef enum
{
    IfxSdmmc_SdIoTransferWidth_1Bit,      /**< \brief 1 Bit Bus width */
    IfxSdmmc_SdIoTransferWidth_reserved,  /**< \brief reserved at Spec */
    IfxSdmmc_SdIoTransferWidth_4Bit,      /**< \brief 4 Bit bus width */
    IfxSdmmc_SdIoTransferWidth_8Bit       /**< \brief 8 Bit bus width */
} IfxSdmmc_SdIoTransferWidth;

/** \brief SD modes supported by HOST
 * Definition in IfxSdmmc_Sd_HostConfig.supportedModes
 */
typedef enum
{
    IfxSdmmc_SdModes_ioOnly,   /**< \brief Support only SDIO mode */
    IfxSdmmc_SdModes_memOnly,  /**< \brief support only SD memory mode */
    IfxSdmmc_SdModes_combo     /**< \brief support Combo cards */
} IfxSdmmc_SdModes;

/** \brief Speed Mode\n
 * Definition in HOST_CTRL1.HIGH_SPEED_EN
 */
typedef enum
{
    IfxSdmmc_SdSpeedMode_normal,  /**< \brief Normal Speed MOde */
    IfxSdmmc_SdSpeedMode_high     /**< \brief High Speed Mode */
} IfxSdmmc_SdSpeedMode;

/** \brief Status of the SDMMC hardware
 */
typedef enum
{
    IfxSdmmc_Status_success,                   /**< \brief Success */
    IfxSdmmc_Status_failure,                   /**< \brief Failure */
    IfxSdmmc_Status_commandLineBusy,           /**< \brief command Line Busy */
    IfxSdmmc_Status_dataLineBusy,              /**< \brief data Line Busy */
    IfxSdmmc_Status_commandError,              /**< \brief Command Error */
    IfxSdmmc_Status_responseError,             /**< \brief Response Error */
    IfxSdmmc_Status_timeout,                   /**< \brief Timeout */
    IfxSdmmc_Status_badResponse,               /**< \brief Bad Response */
    IfxSdmmc_Status_initialisedButLocked,      /**< \brief Initialised but locked */
    IfxSdmmc_Status_cardNotInitialised,        /**< \brief Card not initialised */
    IfxSdmmc_Status_cardLocked,                /**< \brief Card Locked */
    IfxSdmmc_Status_cardWrProtected,           /**< \brief Card Write Protected */
    IfxSdmmc_Status_bufferReady,               /**< \brief Buffer Ready */
    IfxSdmmc_Status_dataError,                 /**< \brief Data Error */
    IfxSdmmc_Status_configurationNotSupported  /**< \brief configuration Not Supported */
} IfxSdmmc_Status;

/** \brief Transfer Direction\n
 * Definition in XFER_MODE.DATA_XFER_DIR
 */
typedef enum
{
    IfxSdmmc_TransferDirection_write,  /**< \brief Write, Host to Card */
    IfxSdmmc_TransferDirection_read    /**< \brief Read, Card to Host */
} IfxSdmmc_TransferDirection;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Sdmmc_Std_DataStrctures
 * \{ */
/** \brief R4 response Bits: Card information
 */
typedef struct
{
    uint32 ocr : 24;		/**< \brief Indicates supported voltage range. Range: 0 to 0xFFFFFF */
    uint32 s18a : 1;		/**< \brief 1.8V Signaling Support Indicator. Note: voltage switch sequences using CMD11 are skipped as the controller does not support 1.8V operation. */
    uint32 stuff : 2;
    uint32 mp : 1;			/**< Memory present indicator. Range: 1 -> if Memory present in card, 0 ->  if Memory is not present in card */
    uint32 ioNum : 3;		/**< Specifies the Number of I/O functions supported by the card. Range: 0 -> if Number of functions supported = 0, 1 -> if Number of functions supported = 1, 2 -> if Number of functions supported = 2. */
    uint32 c : 1;			/**< Card Ready bit indicating SDIO card initialization status. Range: \ref IfxSdmmc_SdIoInit_ready (1) SDIO card is Initialized, \ref IfxSdmmc_SdIoInit_notReady (0) SDIO card is Not Initialized. */
} IfxSdmmc_SdIoResponseR4Bits;

/** \} */

/** \addtogroup IfxLld_Sdmmc_Std_DataStrctures
 * \{ */
/** \brief SCR card Register Bitfields\n
 * these bit fields are rearranged to match the SCR register bit fields of card when read by host\n
 * data comes from card to host with MSB(it) first, CPU reads the data with LSB(yte) first.
 */
typedef struct
{
    uint32 sdSpec : 4;           /**< \brief SD_SPEC, [59:56] Range: 0 to 0x15 */
    uint32 scrStructure : 4;     /**< \brief SCR Structure, [63:60] Range: 0 to 0x15 */
    uint32 sdBusWidth : 4;       /**< \brief DAT Bus widths supported, [51:48] Range: 0 to 0x15 */
    uint32 sdSecurity : 3;       /**< \brief CPRM Security Support, [54:52] Range: 0 to 0x7 */
    uint32 eraseStat : 1;        /**< \brief data status after erases, [55:55] Range: 0 or 0x1 */
    uint32 res40 : 2;            /**< \brief Reserved (2), [41:40] Range: 0 to 0x3 */
    uint32 sdSpec4 : 1;          /**< \brief Spec. Version 4.00 or higher, [42:42] Range: 0 or 0x1  */
    uint32 exSecurity : 4;       /**< \brief Extended Security Support, [46:43] Range: 0 to 0x15 */
    uint32 sdSpec3 : 1;          /**< \brief Spec. Version 3.00 or higher, [47:47] Range: 0 or 0x1 */
    uint32 cmdSupport : 4;       /**< \brief Command Support bits, [35:32] Range: 0 to 0x15 */
    uint32 res36 : 4;            /**< \brief Reserved (4), [39:36] Range: 0 to 0x15 */
    uint32 res0 : 32;            /**< \brief Reserved (32), [31:0] Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_CardReg_SCRBits;

/** \brief Card status recieved in response
 */
typedef struct
{
    uint32 res0 : 3;                            /**< \brief Reserved: */
    uint32 authenticationSequenceError : 1;     /**< \brief AKE_SEQ_ERROR (SD Memory Card app. spec.), Error in the sequence of the authentication process. Range: 0 or 0x1 */
    uint32 res4 : 1;                            /**< \brief Reserved. */
    uint32 acmd : 1;                            /**< \brief APP_CMD, The card will expect ACMD, or an indication that the command has been interpreted as ACMD. Range: 0 or 0x1*/
    uint32 functionEvent : 1;                   /**< \brief FX_EVENT, Extension Functions may set this bit to get host to deal with events. Range: 0 or 0x1 */
    uint32 res7 : 1;                            /**< \brief Reserved. */
    uint32 readyForData : 1;                    /**< \brief READY_FOR_DATA, Corresponds to buffer empty signaling on the bus. Range: 0 or 0x1 */
    uint32 currentState : 4;                    /**< \brief CURRENT_STATE, The state of the card when receiving the command. Range: 0 to 0xF */
    uint32 eraseReset : 1;                      /**< \brief ERASE_RESET, An erase sequence was cleared before executing because an out of erase sequence command was received. Range: 0 or 0x1 */
    uint32 eccDisabled : 1;                     /**< \brief CARD_ECC_DISABLED, The command has been executed without using the internal ECC. Range: 0 or 0x1 */
    uint32 wpEraseSkip : 1;                     /**< \brief WP_ERASE_SKIP, Set when only partial address space was erased due to existing write protected blocks or the temporary or permanent write protected card was erased. Range: 0 or 0x1 */
    uint32 csdOverwrite : 1;                    /**< \brief CSD_OVERWRITE, Can be either one of the following errors:\n
                                                 * - The read only section of the CSD does not match the card content.\n
                                                 * - An attempt to reverse the copy (set as original) or permanent WP (unprotected) bits was made. */
    uint32 res17 : 1;                           /**< \brief Reserved. */
    uint32 res18 : 1;                           /**< \brief Reserved. */
    uint32 error : 1;                           /**< \brief ERROR, A general or an unknown error occurred during the operation. Range: 0 or 0x1 */
    uint32 ccError : 1;                         /**< \brief CC_ERROR, Internal card controller error. Range: 0 or 0x1 */
    uint32 eccFailed : 1;                       /**< \brief CARD_ECC_FAILED, Card internal ECC was applied but failed to correct the data. Range: 0 or 0x1 */
    uint32 illegalCommand : 1;                  /**< \brief ILLEGAL_COMMAND, Command not legal for the card state. Range: 0 or 0x1 */
    uint32 commandCrcError : 1;                 /**< \brief COM_CRC_ERROR, The CRC check of the previous command failed. Range: 0 or 0x1 */
    uint32 lockUnlockFailed : 1;                /**< \brief LOCK_UNLOCK_FAILED, Set when a sequence or password error has been detected in lock/unlock card command. Range: 0 or 0x1 */
    uint32 locked : 1;                          /**< \brief CARD_IS_LOCKED, When set, signals that the card is locked by the host. Range: 0 or 0x1*/
    uint32 wpViolation : 1;                     /**< \brief WP_VIOLATION, Set when the host attempts to write to a protected block or to the temporary or permanent write protected card. Range: 0 or 0x1 */
    uint32 eraseParam : 1;                      /**< \brief ERASE_PARAM, An invalid selection of write-blocks for erase occurred. Range: 0 or 0x1 */
    uint32 eraseSeqError : 1;                   /**< \brief ERASE_SEQ_ERROR, An error in the sequence of erase commands occurred. Range: 0 or 0x1 */
    uint32 blockLengthError : 1;                /**< \brief BLOCK_LEN_ERROR, The transferred block length is not allowed for this card, or the number of transferred bytes does not match the block length. Range: 0 or 0x1 */
    uint32 addressError : 1;                    /**< \brief ADDRESS_ERROR, A misaligned address which did not match the block length was used in the command. Range: 0 or 0x1 */
    uint32 outOfRange : 1;                      /**< \brief OUT_OF_RANGE, The command's argument was out of the allowed range for this card. Range: 0 or 0x1 */
} IfxSdmmc_CardStatusBits;

/** \brief R4 response
 */
typedef union
{
    IfxSdmmc_SdIoResponseR4Bits bits;		/**< Provides access to individual R4 response bitfields. */
    uint32                      r4;			/**< Represents the card's operating conditions as specified in the response. Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_SdIoResponseR4;

/** \} */

/** \addtogroup IfxLld_Sdmmc_Std_DataStrctures
 * \{ */
/** \brief Card register SCR
 */
typedef union
{
    uint32                   U[2];       /**< \brief Word access. */
    IfxSdmmc_CardReg_SCRBits B;          /**< \brief SCR card Register Bitfields. */
} IfxSdmmc_CardReg_SCR;

/** \brief Card Status
 */
typedef union
{
    IfxSdmmc_CardStatusBits B;       /**< \brief Card status in Bits format. */
    uint32                  U;       /**< \brief Card Status in word format. */
} IfxSdmmc_CardStatus;

typedef struct
{
    uint32 data : 8;               /**< \brief Data to be written or read. Range: 0 to 0xFF */
    uint32 stuff1 : 1;          
    uint32 regAddr : 17;           /**< \brief Register address for the operation. Range: 0 to 0x1FFFF */
    uint32 stuff2 : 1;            
    uint32 raw : 1;                /**< \brief Raw flag. Range: TRUE if the operation is raw, FALSE if it is not. */
    uint32 func : 3;			   /**< \brief Specifies the I/O function number (0 to 7) to target for the operation. Range: \ref IfxSdmmc_SdIoFunction */
    uint32 rw : 1;                 /**< \brief Indicates read or write operation. Range: TRUE Performs write operation, FALSE Performs read operation. */
} IfxSdmmc_SdIoCmd52Bits;

/** \brief CMD53 Command bitfield Structure
 */
typedef struct
{
    uint32 Count : 9; 		/**< \brief Specifies the number of data blocks. Range: 0 to 0x1FF */
    uint32 regAddr : 17;    /**< \brief Specifies register address. The starting address for the transfer. Range: 0 to 0x1FFFF */
    uint32 opCode : 1;		/**< \brief Performs write/read to incrementing address. Range: 1 -> Write to incrementing address, 0 -> Read from incrementing address. */
    uint32 blockMode : 1;	/**< \brief Specifies Data transfer mode. Range: 0 -> Byte mode (transfer by bytes), 1 -> Block mode (transfer by blocks). */
    uint32 func : 3;		/**< \brief Specifies the I/O function number (0 to 7) to target for the operation. Range: \ref IfxSdmmc_SdIoFunction */
    uint32 rw : 1;			/**< \brief Specifies Read/Write direction. Range: 0 -> Read from card to host, 1 -> Write from host to card. */
} IfxSdmmc_SdIoCmd53Bits;

/** \brief R5 response: bit field structure
 */
typedef struct
{
    uint32 data : 8;		/**< \brief Data byte returned by the card for read operations. Range: 0 to 0xFF */
    uint32 flags : 8;		/**< \brief Status and error flags. Range: 0 to 0xFF */
    uint32 stuff : 16;
} IfxSdmmc_SdIoResponseR5Bits;

/** \brief SDIO card information
 */
typedef struct
{
    IfxSdmmc_SdIoResponseR4 ioInfo;		/**< \brief Bitfield structure for R4 response. */
} IfxSdmmc_SdIo_CardInfo;

/** \} */

/** \addtogroup IfxLld_Sdmmc_Std_DataStrctures
 * \{ */
/** \brief Descriptor for ADMA2 transfers
 */
typedef struct
{
    uint32 valid : 1;            /**< \brief Indicates validity of a descriptor line. */
    uint32 end : 1;              /**< \brief End of Descriptor. Range: 1 -> Indicate this is the last descriptor, signaling the end of the data transfer, 0 -> Indicate this is not the last descriptor, continue to the next in the sequence. */
    uint32 intEn : 1;            /**< \brief Force to generate ADMA Interrupt. 
                                  * - Range: 1 -> Enables an interrupt when the last data transfer in the descriptor table is completed, 0 -> Do not trigger an interrupt after the completion of this descriptor's data transfer. */
    uint32 act : 3;              /**< \brief Action Symbols combination. Range: \ref IfxSdmmc_AdmaActionSymbol */
    uint32 lengthUpper : 10;     /**< \brief Upper value of the Length in 26 bit length mode. Range: 0 to 0x3FF */
    uint32 length : 16;          /**< \brief data length (lower part of the length in 26 bit length mode). Range: 0 to 0x200 */
    uint32 address : 32;         /**< \brief Address of the data location. Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_Adma2Descriptor;

/** \brief Card information structure, contents of Card registers.
 */
typedef struct
{
    uint32                 ocr;          /**< \brief OCR register contents. Range: 0 to 0xFFFFFFFF */
    uint32                 cid[4];       /**< \brief CID register contents. Range: 0 to 0xFFFFFFFF */
    uint32                 csd[4];       /**< \brief CSD register contents. Range: 0 to 0xFFFFFFFF */
    IfxSdmmc_CardReg_SCR   scr;          /**< \brief SCR register contents. */
    uint16                 rca;          /**< \brief RCA register contents. Range: 0 to 0xFFFF */
    uint16                 dsr;          /**< \brief DSR register contents. Range: 0 to 0xFFFF */
    IfxSdmmc_SdIo_CardInfo io;           /**< \brief SDIO card info. */
} IfxSdmmc_CardInfo;

/** \brief Configuration structure for Normal and Error interrupts
 */
typedef struct
{
    boolean      commandCompleteInterruptEnable;        /**< \brief Command Complete Interrupt Enable/Disable selection. Range: TRUE Command complete interrupt enabled, FALSE Command complete interrupt disable. */
    boolean      transferCompleteInterruptEnable;       /**< \brief Transfer Complete Interrupt Enable/Disable selection. Range: TRUE transfer complete interrupt enabled, FALSE Transfer complete interrupt disable. */
    boolean      dmaInterruptEnable;                    /**< \brief Transfer Complete Interrupt Enable/Disable selection Range: TRUE Dma interrupt enabled, FALSE Dma interrupt disable. */
    boolean      commandTimeoutInterruptEnable;         /**< \brief Command Timeout Interrupt Enable/Disable selection Range: TRUE Command timeout interrupt enabled, FALSE Command timeout interrupt disable. */
    boolean      dataTimeoutInterruptEnable;            /**< \brief Data Timeout Interrupt Enable/Disable selection Range: TRUE Data time out interrupt enabled, FALSE Data time out disable.  */
    Ifx_Priority priority;                              /**< \brief Interrupt service priority. */
    IfxSrc_Tos   provider;                              /**< \brief Interrupt service provider. */
} IfxSdmmc_InterruptConfig;

/** \brief Response Data
 */
typedef struct
{
    IfxSdmmc_CardStatus cardStatus;       /**< \brief Card status recieved in response. */
    uint32              resp01;           /**< \brief Response Register 01 value. Range: 0 to 0xFFFFFFFF */
    uint32              resp23;           /**< \brief Response register 23 value. Range: 0 to 0xFFFFFFFF */
    uint32              resp45;           /**< \brief Response register 45 value. Range: 0 to 0xFFFFFFFF */
    uint32              resp67;           /**< \brief Response register 67 value. Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_Response;

/** \brief CMD52 command
 */
typedef union
{
    IfxSdmmc_SdIoCmd52Bits bits;        /**< \brief Bitfield structure for CMD52. */
    uint32                 arg;         /**< \brief Raw argument value. Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_SdIoCmd52;

/** \brief CMD53 Command
 */
typedef union
{
    IfxSdmmc_SdIoCmd53Bits bits;        /**< \brief Bitfield structure for CMD53. */
    uint32                 arg;         /**< \brief Raw argument value. Range: 0 to 0xFFFFFFFF */
} IfxSdmmc_SdIoCmd53;

/** \brief SDIO Response R5
 */
typedef union
{
    uint32                      r5;		/**< \brief Response register r5 value. Range: 0 to 0xFFFFFFFF */
    IfxSdmmc_SdIoResponseR5Bits bits;   /**< \brief Bitfield structure for R5 Response. */
} IfxSdmmc_SdIoResponseR5;

/** \} */

/** \addtogroup IfxLld_Sdmmc_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Applies the software reset of the SDMMC module
 * 
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * 
 * \retval None
 */
IFX_INLINE void IfxSdmmc_applySoftwareReset(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if there is any error in the response received from the card.
 *
 * \param[in] cardStatus The status received from the card.
 * 					     Range: 0 to 0xFFFFFFFF
 *
 * \retval IfxSdmmc_Status The status indicating success or failure. A return value of 0 indicates success,
 * 					       while any non-zero value indicates an error.
 * 					       Range: \ref IfxSdmmc_Status
 */
IFX_INLINE IfxSdmmc_Status IfxSdmmc_checkErrorInResponseR6(uint32 cardStatus);

/**
 * \brief Clears the specified error interrupt status flag for the SDMMC module.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt Error interrupt status flag to clear.
 * 						   Range: \ref IfxSdmmc_ErrorInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_clearErrorInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt);

/**
 * \brief Clears the specified normal interrupt status flag within the SDMMC module.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt The normal interrupt to clear.
 * 				           Range: \ref IfxSdmmc_NormalInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_clearNormalInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt);

/**
 * \brief Disables the block count feature during data transfer operations.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_disableBlockCount(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Disables the SDMMC card clock to reduce power consumption when communication with the card is not needed.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *                        This pointer is used to access the SDMMC module's registers to control the card clock.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_disableCardClock(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables all error interrupts for interrupt generation.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableAllErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the Block count in transfer mode
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableBlockCount(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the clock for the SD card interface
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableCardClock(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables DMA transfers for the SDMMC host controller by configuring the necessary registers.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space. This parameter provides access
 * 					      to the SDMMC controller's registers, which are used to enable DMA functionality.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableDmaTransfers(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the selected Error Interrupt for interrupt generation.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt The specific error interrupt to enable.
 * 			               Range: \ref IfxSdmmc_ErrorInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableErrorInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt);

/**
 * \brief Enables the selected Error Interrupt for interrupt generation.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt Error interrupt to be enabled.
 * 						   Range: \ref IfxSdmmc_ErrorInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt);

/**
 * \brief Enables the SDMMC host controller version 4, configuring it for operation.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *                        This parameter must not be NULL and should point to a valid
 *                        SDMMC peripheral register structure.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableHostControllerVersion4(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the internal clock of the SDMMC host controller
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableInternalClock(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the specified normal interrupt for interrupt generation.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt Normal interrupt to be enabled.
 * 				           Range: \ref IfxSdmmc_NormalInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableNormalInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt);

/**
 * \brief Enables the Phase-Locked Loop (PLL) of the SDMMC host controller
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space,
 *                        which contains the control and status registers for the SDMMC peripheral.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enablePll(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Enables the selected Normal Interrupt status for interrupt generation.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    interrupt Normal Interrupt enumeration specifying which interrupt status to enable.
 * 						   Range: \ref IfxSdmmc_NormalInterrupt
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enableNormalInterruptStatus(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt);

/**
 * \brief Enables the preset values for clock generation.
 *
 * This function configures the SDMMC controller to use predefined clock generation settings.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_enablePresetValues(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Retrieves the current state of the Error Interrupt Status register.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * 
 * \retval uint16 The current value of the Error Interrupt Status register
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint16 IfxSdmmc_getErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Retrieves the current value of the Normal Interrupt Status register.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval uint16 The current value of the Normal Interrupt Status register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint16 IfxSdmmc_getNormalInterruptStatus(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Returns the Src Pointer of the selected SDMMC service request node
 *
 * \param[in] sdmmcSFR      Pointer to the base address of the SDMMC register space
 * \param[in] interruptType Interrupt type specifying the service request node number.
 * 							Range: \ref IfxSdmmc_InterruptType
 *
 * \retval Ifx_SRC_SRCR Pointer to the Src Pointer of the selected service request node.
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxSdmmc_getSrcPointer(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_InterruptType interruptType);

/**
 * \brief Checks if the command line is busy and unable to accept new commands.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval TRUE  if the command line is busy.
 *         FALSE if the command line is not busy.
 */
IFX_INLINE boolean IfxSdmmc_isCommandLineBusy(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if the data line is busy for issuing a command with data.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval TRUE  if data line is busy.
 *         FALSE if data line is not busy.
 */
IFX_INLINE boolean IfxSdmmc_isDataLineBusy(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if a specific error interrupt flag is set for the SDMMC module.
 *
 * \param[in] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in] interrupt The specific error interrupt to check.
 * 						Range: \ref IfxSdmmc_ErrorInterrupt
 *
 * \retval TRUE  if the specified error interrupt flag is set.
 *         FALSE if the specified error interrupt flag is not set.
 */
IFX_INLINE boolean IfxSdmmc_isErrorInterruptOccured(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt);

/**
 * \brief Indicates whether the host controller supports version 4 functionality.
 *
 * This function checks if the host controller has version 4 support enabled.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval TRUE  if version 4 support is enabled.
 *         FALSE if version 4 support is disabled.
 */
IFX_INLINE boolean IfxSdmmc_isHostControllerVersion4Enable(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if the internal clock of the SDMMC host controller is stable.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval TRUE  if the internal clock is stable and ready for operation.
 *     	   FALSE if the internal clock is not yet stable.
 */
IFX_INLINE boolean IfxSdmmc_isInternalClockStable(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if the SDMMC module's clock is enabled.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval TRUE  if the module's clock is enabled.
 * 		   FALSE if the module's clock is disabled.
 */
IFX_INLINE boolean IfxSdmmc_isModuleEnabled(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Checks if the specified Normal Interrupt flag is set.
 *
 * \param[in] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in] interrupt Normal Interrupt flag to check.
 * 			  		    Range: \ref IfxSdmmc_NormalInterrupt
 *
 * \retval TRUE  if the specified Normal Interrupt flag is set.
 *         FALSE if the specified Normal Interrupt flag is not set.
 */
IFX_INLINE boolean IfxSdmmc_isNormalInterruptOccured(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt);

/**
 * \brief Reads data from the buffer data register of the SDMMC controller.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *                     This pointer provides access to the SDMMC controller's registers.
 *
 * \retval uint32 The data read from the buffer data register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint32 IfxSdmmc_readBufferData(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Reads and returns the contents of the Response Register Resp01.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval uint32 Value of the Resp01 register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint32 IfxSdmmc_readResponseReg01(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Reads and returns the contents of the Response Register 23 (Resp23) for the SDMMC module.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * 
 * \retval uint32 Value of the Resp23 register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint32 IfxSdmmc_readResponseReg23(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Reads and returns the contents of the Response Register 45 (Resp45) for SDMMC operations.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *                     This parameter provides access to the memory-mapped registers of the SDMMC controller.
 *
 * \retval uint32 Value of the Resp45 register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint32 IfxSdmmc_readResponseReg45(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Reads and returns the contents of the Response Register 67 (Resp67) from the SDMMC module.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval uint32 Value of the Resp67 register.
 * 				  Range: 0 to 0xFFFF
 */
IFX_INLINE uint32 IfxSdmmc_readResponseReg67(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sets the value of the Argument register
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space
 * \param[in]    argument Value to be written to the Argument register.
 * 						  Range: 0 to 0xFFFFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setArgument(Ifx_SDMMC *sdmmcSFR, uint32 argument);

/**
 * \brief Sets the block size for SDMMC data transfers
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space
 * \param[in]    size     Block size to be set.
 * 					      Range: 0 to 0xFFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBlockSize(Ifx_SDMMC *sdmmcSFR, uint16 size);

/**
 * \brief Clears the Power Bus On request for the card, effectively powering off the SDMMC bus.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBusPowerOff(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sets the Power Bus On request for the SD/MMC card.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBusPowerOn(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sets the SD Bus Voltage Select for VDD1 (3.3V) or eMMC Bus Voltage Select for VDD (3V).
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBusVoltage(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Configures the SDMMC peripheral to recognize and interact with an eMMC card type.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setCardTypeEmmc(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sets the value to the command register of the SDMMC interface.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    command  Value to be written to the command register.
 * 						  Range: 0 to 0x3FFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setCommand(Ifx_SDMMC *sdmmcSFR, uint16 command);

/**
 * \brief Configures the timeout interval for DAT line detection.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    value    The timeout interval value to be set.
 * 					      Range: \ref IfxSdmmc_DataLineTimeout
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setDataLineTimeoutValue(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_DataLineTimeout value);

/**
 * \brief Selects the type of DMA used for data transfers in host controller.
 *
 * \param[inout] sdmmcSFR Pointer to base address of SDMMC register space.
 * \param[in]    dmaType  Type of DMA used for data transfers in host controller.
 * 						  Range: \ref IfxSdmmc_DmaType
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setDmaType(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_DmaType dmaType);

/**
 * \brief Configures the data width of eMMC transfers in the host controller.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    width    Data width of the eMMC transfers.
 * 					      Range: \ref IfxSdmmc_EmmcDataTransferWidth
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setEmmcDataTransferWidth(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_EmmcDataTransferWidth width);

/**
 * \brief Sets the speed mode of the eMMC transfers in the host controller.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    speed    Speed mode of the eMMC transfers.
 * 					      Range: \ref IfxSdmmc_EmmcSpeedMode
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setEmmcSpeedMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_EmmcSpeedMode speed);

/**
 * \brief Configures the SDMMC controller to operate in either single-block or multi-block transfer mode.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    select   Boolean Flag to enable or disable multi-block mode:
 *                        Range: TRUE  if multi-block mode enabled.
 *                               FALSE if multi-block mode disabled. (use single-block mode).
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setMultiBlockSelect(Ifx_SDMMC *sdmmcSFR, boolean select);

/**
 * \brief Sets the data width of the SD transfers in the host controller, specifying the number of data lines.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    width    Data width of the SD transfers.
 * 						  Range: \ref IfxSdmmc_SdDataTransferWidth
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setSdDataTransferWidth(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_SdDataTransferWidth width);

/**
 * \brief Sets the speed mode of the SD transfers in host controller.
 *
 * \param[inout] sdmmcSFR Pointer to base address of SDMMC register space.
 * \param[in]    speed    Speed Mode of the SD transfers.
 * 						  Range: \ref IfxSdmmc_SdSpeedMode
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setSdSpeedMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_SdSpeedMode speed);

/**
 * \brief Configures the system memory address for DMA transfers.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    address  System memory address for DMA transfers.
 * 						  Range: 0 to 0xFFFFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setSystemAddressForDma(Ifx_SDMMC *sdmmcSFR, uint32 address);

/**
 * \brief Configures the data transfer direction for the SDMMC module.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    direction Data transfer direction.
 * 				 		   Range: \ref IfxSdmmc_TransferDirection
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setTransferDirection(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_TransferDirection direction);

/**
 * \brief Writes data to the buffer data register of the SDMMC.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    data     Pointer to the data buffer to be written.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_writeBufferData(Ifx_SDMMC *sdmmcSFR, uint32 *data);

/**
 * \brief Checks for errors in the R1 response data from the SDMMC card.
 *
 * \param[in] cardStatus R1 response data from the SDMMC card.
 * 						 Range: 0 to 0xFFFFFFFF
 *
 * \retval IfxSdmmc_Status Indicates the error status of the R1 response. A return value of 0 indicates success,
 *  					   while any non-zero value indicates an error.
 * 						   Range: \ref IfxSdmmc_Status
 */
IFX_INLINE IfxSdmmc_Status IfxSdmmc_checkErrorInResponseR1(uint32 cardStatus);

/**
 * \brief Clears the specified error interrupt status flags for the SDMMC module.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    value    Bitmask representing the error interrupt bits to clear. Each bit in
 *                        this value corresponds to an error status flag that will be cleared.
 *                        Range: 0 to 0xFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_clearErrorInterruptAll(Ifx_SDMMC *sdmmcSFR, uint16 value);

/**
 * \brief Clears the specified Normal Interrupt bits in the SDMMC module.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in]    value    Bitmask representing the Normal Interrupt bits to clear.
 * 						  Range: 0 to 0x40FF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_clearNormalInterruptAll(Ifx_SDMMC *sdmmcSFR, uint16 value);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the clock generation parameters for the SDMMC module to operate at a specified frequency.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space. This is the starting address of the SDMMC peripheral's registers.
 * \param[in]    frequency The desired clock frequency to be configured. The actual frequency may be rounded to the nearest supported value by the hardware.
 *                         Range: 0 to 0x2FAF080 (0 Hz to 50 MHz)
 *
 * \retval None
 */
IFX_EXTERN void IfxSdmmc_configureClock(Ifx_SDMMC *sdmmcSFR, uint32 frequency);

/**
 * \brief Enables the SDMMC module
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space
 *
 * \retval None
 */
IFX_EXTERN void IfxSdmmc_enableModule(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Reads the response from response registers based on the specified response type.
 *
 * \param[in]    sdmmcSFR     Pointer to the base address of the SDMMC register space.
 * \param[in]    command      The command to send.
 * 							  Range: \ref IfxSdmmc_Command
 * \param[in]    responseType The type of response to read.
 * 							  Range: \ref IfxSdmmc_ResponseType
 * \param[inout] response     Pointer to the structure where the response data will be stored. The structure
 *                            contains fields for card status and response register values (R01, R23, R45, R67).
 *
 * \retval IfxSdmmc_Status The status of the read Response operation, A return value of 0 indicates success,
 *  					   while any non-zero value indicates an error.
 * 						   Range: \ref IfxSdmmc_Status
 */
IFX_EXTERN IfxSdmmc_Status IfxSdmmc_readResponse(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_Command command, IfxSdmmc_ResponseType responseType, IfxSdmmc_Response *response);

/**
 * \brief Applies the Kernel reset of the module
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space
 *
 * \retval None
 */
IFX_EXTERN void IfxSdmmc_resetModule(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sends an application command to the SD/MMC card.
 *
 * \param[in] sdmmcSFR Pointer to the base address of the SDMMC register space.
 * \param[in] rca      RCA of the target card.
 * 					   Range: 0 to 0xFFFF
 *
 * \retval IfxSdmmc_Status The status of the send Application Command operation, A return value of 0 indicates success,
 *  					   while any non-zero value indicates an error.
 * 						   Range: \ref IfxSdmmc_Status
 */
IFX_EXTERN IfxSdmmc_Status IfxSdmmc_sendApplicationCommand(Ifx_SDMMC *sdmmcSFR, uint16 rca);

/**
 * \brief Sends a command to the SD/MMC card and handles the response.
 *
 * This function issues a specified command to the SD/MMC card, passes the command argument,
 * and retrieves the card's response based on the specified response type.
 *
 * \param[in]    sdmmcSFR     Pointer to the base address of the SDMMC register space.
 * \param[in]    command      The command to be sent to the card.
 * 						      Range: \ref IfxSdmmc_Command
 * \param[in]    argument     Command argument (command-dependent).
 * 						      Range: 0 to 0xFFFFFFFF
 * \param[in]    responseType Type of response expected from the card.
 * 						      Range: \ref IfxSdmmc_ResponseType
 * \param[inout] response     Pointer to the response data structure that will contain the card's response.
 *                            The structure includes card status and response register values.
 *
 * \retval IfxSdmmc_Status The status of the command execution. A return value of 0 indicates success,
 *  					   while any non-zero value indicates an error.
 * 						   Range: \ref IfxSdmmc_Status
 */
IFX_EXTERN IfxSdmmc_Status IfxSdmmc_sendCommand(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_Command command, uint32 argument, IfxSdmmc_ResponseType responseType, IfxSdmmc_Response *response);

/**
 * \brief Configures and initializes the internal clock of the SDMMC host controller.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval IfxSdmmc_Status indicating the success or failure of the internal clock setup. A return value of 0 indicates success,
 *  					   while any non-zero value indicates an error.
 * 						   Range: \ref IfxSdmmc_Status
 */
IFX_EXTERN IfxSdmmc_Status IfxSdmmc_setUpInternalClock(Ifx_SDMMC *sdmmcSFR);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Disables the Phase-Locked Loop (PLL) for the SDMMC module.
 *
 * \param[inout] sdmmcSFR Pointer to the base address of the SDMMC register space.
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_disablePll(Ifx_SDMMC *sdmmcSFR);

/**
 * \brief Sets the block count for multiblock transfers in the SD/MMC interface.
 *
 * \param[in] sdmmcSFR   Pointer to the SDMMC Special Function Register (SFR)
 * \param[in] blockCount The number of blocks to be transferred
 * 					     Range: 0 to 0xFFFFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBlockCount(Ifx_SDMMC *sdmmcSFR, uint32 blockCount);

/**
 * \brief Configures the ADMA2 descriptor length mode for the SDMMC interface.
 *
 * \param[inout] sdmmcSFR Pointer to the SDMMC Special Function Register (SFR) to be configured.
 * \param[in]    mode     The ADMA2 length mode to be set.
 * 						  Range: \ref IfxSdmmc_Adma2LengthMode
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setAdma2LengthMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_Adma2LengthMode mode);

/**
* \brief Enables the automatic command feature for multi-block data transfers.
*
* \param[inout] sdmmcSFR Pointer to base address of SDMMC register space
* \param[in]    select   Auto cmd slection
*						 Range: \ref IfxSdmmc_AutoCmdSelect
* \retval None
*/
IFX_INLINE void IfxSdmmc_setAutoCmdEnable(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_AutoCmdSelect select);

/** \brief Sets the block boundary size
 *
 * \param[inout] sdmmcSFR pointer to base address of SDMMC register space
 * \param[in]    size     Block Boundray Size
 * 						  Range: \ref IfxSdmmc_BlockBoundarySize
 *
 * \retval None
 */
IFX_INLINE void IfxSdmmc_setBlockBoundarySize(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_BlockBoundarySize size);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Switches the clock frequency of communication during runtime.
 *
 * \param[inout] sdmmcSFR  Pointer to the base address of the SDMMC register space.
 * \param[in]    frequency The desired clock frequency to be set (in Hz).
 *                         Range: 0 to 0x2FAF080 (0 Hz to 50 MHz)
 *
 * \retval None
 */
IFX_EXTERN void IfxSdmmc_switchClockFrequency(Ifx_SDMMC *sdmmcSFR, uint32 frequency);

/**
 * \brief Checks for any errors in the response type R5 of an SD/MMC command.
 *
 * \param[in] resp01 The 32-bit response data received from the SD/MMC card.
 *                   Range: 0 to 0xFFFFFFFF
 *
 * \retval IfxSdmmc_Status The status of errors in R5, indicating success or failure. A return value of 0 indicates success,
 *                         while any non-zero value indicates an error.
 *                         Range: \ref IfxSdmmc_Status
 */
IFX_EXTERN IfxSdmmc_Status IfxSdmmc_checkerrorInReponseR5(uint32 resp01);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief Array of all Command Structures defining SD, MMC and Application specific commands
 */
IFX_EXTERN Ifx_SDMMC_CMD_Bits IfxSdmmc_CMD[IFXSDMMC_NUM_COMMANDS];

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSdmmc_applySoftwareReset(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->SW_RST.U |= 1;
}


IFX_INLINE IfxSdmmc_Status IfxSdmmc_checkErrorInResponseR6(uint32 cardStatus)
{
    return (IfxSdmmc_Status)(cardStatus & IFXSDMMC_CARD_R6STATUS_ERROR_CHECK_MSK);
}


IFX_INLINE void IfxSdmmc_clearErrorInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->ERROR_INT_STAT.U &= value;
}


IFX_INLINE void IfxSdmmc_clearNormalInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->NORMAL_INT_STAT.U &= value;
}


IFX_INLINE void IfxSdmmc_disableBlockCount(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->XFER_MODE.B.BLOCK_COUNT_ENABLE = 0;
}


IFX_INLINE void IfxSdmmc_disableCardClock(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->CLK_CTRL.B.SD_CLK_EN = 0;
}


IFX_INLINE void IfxSdmmc_enableAllErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->ERROR_INT_STAT_EN.U = 0xFFFF;
}


IFX_INLINE void IfxSdmmc_enableBlockCount(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->XFER_MODE.B.BLOCK_COUNT_ENABLE = 1;
}


IFX_INLINE void IfxSdmmc_enableCardClock(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->CLK_CTRL.B.SD_CLK_EN = 1;
}


IFX_INLINE void IfxSdmmc_enableDmaTransfers(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->XFER_MODE.B.DMA_ENABLE = 1;
}


IFX_INLINE void IfxSdmmc_enableErrorInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->ERROR_INT_SIGNAL_EN.U |= value;
}


IFX_INLINE void IfxSdmmc_enableErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->ERROR_INT_STAT_EN.U |= value;
}


IFX_INLINE void IfxSdmmc_enableHostControllerVersion4(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->HOST_CTRL2.B.HOST_VER4_ENABLE = 1;
}


IFX_INLINE void IfxSdmmc_enableInternalClock(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->CLK_CTRL.B.INTERNAL_CLK_EN = 1;
}


IFX_INLINE void IfxSdmmc_enableNormalInterrupt(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->NORMAL_INT_SIGNAL_EN.U |= value;
}


IFX_INLINE void IfxSdmmc_enablePll(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->CLK_CTRL.B.PLL_ENABLE = 1;
}


IFX_INLINE void IfxSdmmc_enableNormalInterruptStatus(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt)
{
    uint16 value = 1 << interrupt;
    sdmmcSFR->NORMAL_INT_STAT_EN.U |= value;
}


IFX_INLINE void IfxSdmmc_enablePresetValues(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->HOST_CTRL2.B.PRESET_VAL_ENABLE = 1;
}


IFX_INLINE uint16 IfxSdmmc_getErrorInterruptStatus(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->ERROR_INT_STAT.U;
}


IFX_INLINE uint16 IfxSdmmc_getNormalInterruptStatus(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->NORMAL_INT_STAT.U;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxSdmmc_getSrcPointer(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_InterruptType interruptType)
{
    IFX_UNUSED_PARAMETER(sdmmcSFR)

    if (interruptType == IfxSdmmc_InterruptType_normal)
    {
        return &MODULE_SRC.SDMMC.SDMMC[0].ERR;
    }
    else
    {
        return &MODULE_SRC.SDMMC.SDMMC[0].DMA;
    }
}


IFX_INLINE boolean IfxSdmmc_isCommandLineBusy(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->PSTATE_REG.B.CMD_INHIBIT;
}


IFX_INLINE boolean IfxSdmmc_isDataLineBusy(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->PSTATE_REG.B.CMD_INHIBIT_DAT;
}


IFX_INLINE boolean IfxSdmmc_isErrorInterruptOccured(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_ErrorInterrupt interrupt)
{
    uint16 flag = (1 << interrupt);
    return ((sdmmcSFR->ERROR_INT_STAT.U & flag) != 0) ? 1 : 0;
}


IFX_INLINE boolean IfxSdmmc_isHostControllerVersion4Enable(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->HOST_CTRL2.B.HOST_VER4_ENABLE;
}


IFX_INLINE boolean IfxSdmmc_isInternalClockStable(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->CLK_CTRL.B.INTERNAL_CLK_STABLE;
}


IFX_INLINE boolean IfxSdmmc_isModuleEnabled(Ifx_SDMMC *sdmmcSFR)
{
    return (sdmmcSFR->CLC.B.DISS == 0) ? 1 : 0;
}


IFX_INLINE boolean IfxSdmmc_isNormalInterruptOccured(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_NormalInterrupt interrupt)
{
    uint16 flag = (1 << interrupt);
    return ((sdmmcSFR->NORMAL_INT_STAT.U & flag) != 0) ? 1 : 0;
}


IFX_INLINE uint32 IfxSdmmc_readBufferData(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->BUF_DATA.U;
}


IFX_INLINE uint32 IfxSdmmc_readResponseReg01(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->RESP01.U;
}


IFX_INLINE uint32 IfxSdmmc_readResponseReg23(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->RESP23.U;
}


IFX_INLINE uint32 IfxSdmmc_readResponseReg45(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->RESP45.U;
}


IFX_INLINE uint32 IfxSdmmc_readResponseReg67(Ifx_SDMMC *sdmmcSFR)
{
    return sdmmcSFR->RESP67.U;
}


IFX_INLINE void IfxSdmmc_setArgument(Ifx_SDMMC *sdmmcSFR, uint32 argument)
{
    sdmmcSFR->ARGUMENT.U = argument;
}


IFX_INLINE void IfxSdmmc_setBlockSize(Ifx_SDMMC *sdmmcSFR, uint16 size)
{
    sdmmcSFR->BLOCKSIZE.B.XFER_BLOCK_SIZE = size;
}


IFX_INLINE void IfxSdmmc_setBusPowerOff(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->PWR_CTRL.B.SD_BUS_PWR_VDD1 = 0;
}


IFX_INLINE void IfxSdmmc_setBusPowerOn(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->PWR_CTRL.B.SD_BUS_PWR_VDD1 = 1;
}


IFX_INLINE void IfxSdmmc_setBusVoltage(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->PWR_CTRL.B.SD_BUS_VOL_VDD1 = 7;
}


IFX_INLINE void IfxSdmmc_setCardTypeEmmc(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->EMMC_CTRL.B.CARD_IS_EMMC = 1;
}


IFX_INLINE void IfxSdmmc_setCommand(Ifx_SDMMC *sdmmcSFR, uint16 command)
{
    sdmmcSFR->CMD.U = command;
}


IFX_INLINE void IfxSdmmc_setDataLineTimeoutValue(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_DataLineTimeout value)
{
    sdmmcSFR->TOUT_CTRL.B.TOUT_CNT = value;
}


IFX_INLINE void IfxSdmmc_setDmaType(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_DmaType dmaType)
{
    sdmmcSFR->HOST_CTRL1.B.DMA_SEL = dmaType;
}


IFX_INLINE void IfxSdmmc_setEmmcDataTransferWidth(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_EmmcDataTransferWidth width)
{
    if (width < IfxSdmmc_EmmcDataTransferWidth_8Bit)
    {
        sdmmcSFR->HOST_CTRL1.B.DAT_XFER_WIDTH = width;
    }
    else
    {
        sdmmcSFR->HOST_CTRL1.B.DAT_XFER_WIDTH = 1;
        sdmmcSFR->HOST_CTRL1.B.EXT_DAT_XFER   = 1;
    }
}


IFX_INLINE void IfxSdmmc_setEmmcSpeedMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_EmmcSpeedMode speed)
{
    sdmmcSFR->HOST_CTRL2.B.UHS_MODE_SEL = speed;
}


IFX_INLINE void IfxSdmmc_setMultiBlockSelect(Ifx_SDMMC *sdmmcSFR, boolean select)
{
    sdmmcSFR->XFER_MODE.B.MULTI_BLK_SEL = select;
}


IFX_INLINE void IfxSdmmc_setSdDataTransferWidth(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_SdDataTransferWidth width)
{
    sdmmcSFR->HOST_CTRL1.B.DAT_XFER_WIDTH = width;
}


IFX_INLINE void IfxSdmmc_setSdSpeedMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_SdSpeedMode speed)
{
    sdmmcSFR->HOST_CTRL1.B.HIGH_SPEED_EN = speed;
}


IFX_INLINE void IfxSdmmc_setSystemAddressForDma(Ifx_SDMMC *sdmmcSFR, uint32 address)
{
    if (IfxSdmmc_isHostControllerVersion4Enable(sdmmcSFR))
    {
        sdmmcSFR->ADMA_SA_LOW.U = address;
    }
    else
    {
        sdmmcSFR->SDMASA.U = address;
    }
}


IFX_INLINE void IfxSdmmc_setTransferDirection(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_TransferDirection direction)
{
    sdmmcSFR->XFER_MODE.B.DATA_XFER_DIR = direction;
}


IFX_INLINE void IfxSdmmc_writeBufferData(Ifx_SDMMC *sdmmcSFR, uint32 *data)
{
    sdmmcSFR->BUF_DATA.U = *data;
}


IFX_INLINE void IfxSdmmc_disablePll(Ifx_SDMMC *sdmmcSFR)
{
    sdmmcSFR->CLK_CTRL.B.PLL_ENABLE = 0;
}


IFX_INLINE IfxSdmmc_Status IfxSdmmc_checkErrorInResponseR1(uint32 cardStatus)
{
    return ((cardStatus & IFXSDMMC_CARD_IOONLY_STATUS_CHECK_MSK) == IFXSDMMC_CARD_IOONLY_STATUS_CHECK_MSK) ? (IfxSdmmc_Status)(cardStatus & IFXSDMMC_CARD_R1STATUS_ERROR_CHECK_MSK) : (IfxSdmmc_Status)(cardStatus & IFXSDMMC_IOCARD_R1STATUS_ERROR_CHECK_MSK);
}


IFX_INLINE void IfxSdmmc_setBlockCount(Ifx_SDMMC *sdmmcSFR, uint32 blockCount)
{
    if (IfxSdmmc_isHostControllerVersion4Enable(sdmmcSFR))
    {
        sdmmcSFR->SDMASA.U = blockCount;
    }
    else
    {
        sdmmcSFR->BLOCKCOUNT.U = (uint16)blockCount;
    }
}


IFX_INLINE void IfxSdmmc_setAdma2LengthMode(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_Adma2LengthMode mode)
{
    sdmmcSFR->HOST_CTRL2.B.ADMA2_LEN_MODE = mode;
}


IFX_INLINE void IfxSdmmc_setAutoCmdEnable(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_AutoCmdSelect select)
{
    sdmmcSFR->XFER_MODE.B.AUTO_CMD_ENABLE = select;
}


IFX_INLINE void IfxSdmmc_clearErrorInterruptAll(Ifx_SDMMC *sdmmcSFR, uint16 value)
{
    sdmmcSFR->ERROR_INT_STAT.U = value;
}


IFX_INLINE void IfxSdmmc_clearNormalInterruptAll(Ifx_SDMMC *sdmmcSFR, uint16 value)
{
    sdmmcSFR->NORMAL_INT_STAT.U = value;
}


IFX_INLINE void IfxSdmmc_setBlockBoundarySize(Ifx_SDMMC *sdmmcSFR, IfxSdmmc_BlockBoundarySize size)
{
    sdmmcSFR->BLOCKSIZE.B.SDMA_BUF_BDARY = size;
}


#endif /* IFXSDMMC_H */
